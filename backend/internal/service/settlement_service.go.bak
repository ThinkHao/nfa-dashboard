package service

import (
	"fmt"
	"log"
	"sync"
	"time"

	"nfa-dashboard/internal/model"
	"nfa-dashboard/internal/repository"
)

// SettlementService 结算服务接口
type SettlementService interface {
	// 获取结算配置
	GetSettlementConfig() (*model.SettlementConfig, error)
	// 更新结算配置
	UpdateSettlementConfig(config *model.SettlementConfig) error
	// 创建结算任务
	CreateSettlementTask(taskType string, taskDate time.Time) (*model.SettlementTask, error)
	// 更新结算任务状态
	UpdateSettlementTaskStatus(taskID int64, status string, errorMsg string) error
	// 删除结算任务
	DeleteSettlementTask(id int64) error
	// 获取结算任务列表
	GetSettlementTasks(taskType, status string, startDate, endDate time.Time, limit, offset int) ([]model.SettlementTaskResponse, int64, error)
	// 获取结算任务详情
	GetSettlementTaskByID(id int64) (*model.SettlementTaskResponse, error)
	// 获取结算数据列表
	GetSettlements(filter model.SettlementFilter) ([]model.SettlementResponse, int64, error)
	// 执行日结算任务
	ExecuteDailySettlement(taskID int64, date time.Time) error
	// 执行周结算任务
	ExecuteWeeklySettlement(taskID int64, weekStartDate time.Time) error
	// 执行周结算任务（支持日期范围）
	ExecuteWeeklySettlementWithDateRange(taskID int64, startDate, endDate time.Time) error
}

// settlementService 结算服务实现
type settlementService struct {
	repo repository.SettlementRepository
}

// NewSettlementService 创建结算服务实例
func NewSettlementService(repo repository.SettlementRepository) SettlementService {
	return &settlementService{
		repo: repo,
	}
}

// GetSettlementConfig 获取结算配置
func (s *settlementService) GetSettlementConfig() (*model.SettlementConfig, error) {
	return s.repo.GetSettlementConfig()
}

// UpdateSettlementConfig 更新结算配置
func (s *settlementService) UpdateSettlementConfig(config *model.SettlementConfig) error {
	return s.repo.UpdateSettlementConfig(config)
}

// CreateSettlementTask 创建结算任务
func (s *settlementService) CreateSettlementTask(taskType string, taskDate time.Time) (*model.SettlementTask, error) {
	now := time.Now()
	task := &model.SettlementTask{
		TaskType:       taskType,
		TaskDate:       taskDate,
		Status:         "pending",
		ProcessedCount: 0,
		CreateTime:     now,
		UpdateTime:     now,
	}

	err := s.repo.CreateSettlementTask(task)
	if err != nil {
		return nil, err
	}

	// 获取创建后的任务，确保有正确的ID
	var tasks []model.SettlementTask
	filter := map[string]interface{}{
		"task_type": taskType,
		"task_date": taskDate,
	}
	tasks, _, err = s.repo.GetSettlementTasks(filter, 1, 0)
	if err != nil || len(tasks) == 0 {
		// 如果查询失败，返回原始任务
		return task, nil
	}

	// 返回最新创建的任务
	return &tasks[0], nil
}

// UpdateSettlementTaskStatus 更新结算任务状态
func (s *settlementService) UpdateSettlementTaskStatus(taskID int64, status string, errorMsg string) error {
	task, err := s.repo.GetSettlementTaskByID(taskID)
	if err != nil {
		return err
	}

	task.Status = status
	if status == "running" {
		task.StartTime = time.Now()
	} else if status == "success" || status == "failed" {
		task.EndTime = time.Now()
	}

	if errorMsg != "" {
		task.ErrorMessage = errorMsg
	}

	return s.repo.UpdateSettlementTask(task)
}

// DeleteSettlementTask 删除结算任务
func (s *settlementService) DeleteSettlementTask(id int64) error {
	// 首先检查任务是否存在
	task, err := s.repo.GetSettlementTaskByID(id)
	if err != nil {
		return err
	}

	// 检查任务状态，不允许删除正在运行的任务
	if task.Status == "running" {
		return fmt.Errorf("不能删除正在运行的任务")
	}

	// 删除任务
	return s.repo.DeleteSettlementTask(id)
}

// GetSettlementTasks 获取结算任务列表
func (s *settlementService) GetSettlementTasks(taskType, status string, startDate, endDate time.Time, limit, offset int) ([]model.SettlementTaskResponse, int64, error) {
	filter := make(map[string]interface{})

	if taskType != "" {
		filter["task_type"] = taskType
	}

	if status != "" {
		filter["status"] = status
	}

	if !startDate.IsZero() {
		filter["task_date >= ?"] = startDate
	}

	if !endDate.IsZero() {
		filter["task_date <= ?"] = endDate
	}

	tasks, count, err := s.repo.GetSettlementTasks(filter, limit, offset)
	if err != nil {
		return nil, 0, err
	}

	var responses []model.SettlementTaskResponse
	for _, task := range tasks {
		responses = append(responses, model.SettlementTaskResponse{
			ID:             task.ID,
			TaskType:       task.TaskType,
			TaskDate:       task.TaskDate,
			Status:         task.Status,
			StartTime:      task.StartTime,
			EndTime:        task.EndTime,
			ProcessedCount: task.ProcessedCount,
			ErrorMessage:   task.ErrorMessage,
			CreateTime:     task.CreateTime,
			UpdateTime:     task.UpdateTime,
		})
	}

	return responses, count, nil
}

// GetSettlementTaskByID 获取结算任务详情
func (s *settlementService) GetSettlementTaskByID(id int64) (*model.SettlementTaskResponse, error) {
	task, err := s.repo.GetSettlementTaskByID(id)
	if err != nil {
		return nil, err
	}

	response := &model.SettlementTaskResponse{
		ID:             task.ID,
		TaskType:       task.TaskType,
		TaskDate:       task.TaskDate,
		Status:         task.Status,
		StartTime:      task.StartTime,
		EndTime:        task.EndTime,
		ProcessedCount: task.ProcessedCount,
		ErrorMessage:   task.ErrorMessage,
		CreateTime:     task.CreateTime,
		UpdateTime:     task.UpdateTime,
	}

	return response, nil
}

// GetSettlements 获取结算数据列表
func (s *settlementService) GetSettlements(filter model.SettlementFilter) ([]model.SettlementResponse, int64, error) {
	return s.repo.GetSettlements(filter)
}

// ExecuteDailySettlement 执行日结算任务
func (s *settlementService) ExecuteDailySettlement(taskID int64, date time.Time) error {
	// 更新任务状态为运行中
	err := s.UpdateSettlementTaskStatus(taskID, "running", "")
	if err != nil {
		return fmt.Errorf("更新任务状态失败: %v", err)
	}

	settlements, processedCount, err := s.executeDailySettlementInternal(date)
	if err != nil {
		s.UpdateSettlementTaskStatus(taskID, "failed", fmt.Sprintf("执行日结算失败: %v", err))
		return fmt.Errorf("执行日结算失败: %v", err)
	}

	if len(settlements) > 0 {
		log.Printf("开始保存日结算数据，共 %d 条", len(settlements))
		err = s.repo.BatchCreateSettlements(settlements)
		if err != nil {
			s.UpdateSettlementTaskStatus(taskID, "failed", fmt.Sprintf("保存结算数据失败: %v", err))
			return fmt.Errorf("保存结算数据失败: %v", err)
		}
		log.Printf("日结算数据保存成功")
	} else {
		log.Printf("没有日结算数据需要保存")
	}

	task, err := s.repo.GetSettlementTaskByID(taskID)
	if err != nil {
		return fmt.Errorf("获取任务信息失败: %v", err)
	}

	task.Status = "success"
	task.EndTime = time.Now()
	task.ProcessedCount = processedCount

	err = s.repo.UpdateSettlementTask(task)
	if err != nil {
		return fmt.Errorf("更新任务状态失败: %v", err)
	}

	return nil
}

// executeDailySettlementInternal 内部方法，执行日结算的实际计算逻辑
// 返回结算数据、处理记录数和错误
func (s *settlementService) executeDailySettlementInternal(date time.Time) ([]model.SchoolSettlement, int, error) {
	log.Printf("开始计算 %s 的日结算数据", date.Format("2006-01-02"))
	
	processedCount := 0
	var settlements []model.SchoolSettlement

	// 直接获取所有存在的学校、地区、运营商的有效组合
	// 构建SQL，获取所有唯一的学校ID、地区、运营商组合
	type SchoolRegionCP struct {
		SchoolID   string
		SchoolName string
		Region     string
		CP         string
	}
	
	var validCombinations []SchoolRegionCP
	query := "SELECT DISTINCT school_id, school_name, region, cp FROM nfa_school"
	err := model.DB.Raw(query).Scan(&validCombinations).Error
	if err != nil {
		return nil, 0, fmt.Errorf("获取有效学校组合失败: %v", err)
	}
	
	log.Printf("找到 %d 个有效的学校、地区、运营商组合", len(validCombinations))
	
	// 为每个有效组合计箕95值
	for _, combo := range validCombinations {
		// 计箕95值，传入学校ID、地区和运营商
		settlement, err := s.repo.CalculateDaily95WithRegionAndCP(date, combo.SchoolID, combo.Region, combo.CP)
		if err != nil {
			log.Printf("计算学校 %s 在地区 %s 运营商 %s 的日95值失败: %v", 
				combo.SchoolName, combo.Region, combo.CP, err)
			continue
		}

		if settlement != nil {
			settlements = append(settlements, *settlement)
			processedCount++
		}
	}
	
	log.Printf("完成 %s 的日结算计算，共生成 %d 条数据", date.Format("2006-01-02"), processedCount)
	return settlements, processedCount, nil
}

	task.Status = "success"
	task.EndTime = time.Now()
	task.ProcessedCount = processedCount

	err = s.repo.UpdateSettlementTask(task)
	if err != nil {
		return fmt.Errorf("更新任务状态失败: %v", err)
	}

	return nil
}

// ExecuteWeeklySettlement 执行周结算任务
func (s *settlementService) ExecuteWeeklySettlement(taskID int64, weekStartDate time.Time) error {
	// 默认结束日期为开始日期后的6天（一周）
	weekEndDate := weekStartDate.AddDate(0, 0, 6)
	return s.ExecuteWeeklySettlementWithDateRange(taskID, weekStartDate, weekEndDate)
}

// ExecuteWeeklySettlementWithDateRange 执行周结算任务（支持自定义日期范围）
func (s *settlementService) ExecuteWeeklySettlementWithDateRange(taskID int64, startDate, endDate time.Time) error {
	log.Printf("开始执行周结算任务 ID=%d", taskID)
	
	// 更新任务状态为运行中
	err := s.UpdateSettlementTaskStatus(taskID, "running", "")
	if err != nil {
		return fmt.Errorf("更新任务状态失败: %v", err)
	}

	// 获取所有学校
	schoolRepo := repository.NewSchoolRepository()
	schools, _, err := schoolRepo.GetAllSchools(nil, 1000, 0)
	if err != nil {
		s.UpdateSettlementTaskStatus(taskID, "failed", fmt.Sprintf("获取学校列表失败: %v", err))
		return fmt.Errorf("获取学校列表失败: %v", err)
	}

	// 计算日期范围内的天数
	daysCount := int(endDate.Sub(startDate).Hours() / 24) + 1
	log.Printf("开始计算从 %s 到 %s 的结算数据，共 %d 天", 
		startDate.Format("2006-01-02"), endDate.Format("2006-01-02"), daysCount)

	// 使用通道来控制并发数量
	maxConcurrent := 7 // 最大并发数
	semaphore := make(chan struct{}, maxConcurrent)

	// 使用WaitGroup来等待所有日期的结算完成
	var wg sync.WaitGroup
	
	// 使用互斥锁保护共享数据
	var mu sync.Mutex
	var settlements []model.SchoolSettlement
	processedCount := 0
	
	// 进度跟踪
	completedDays := 0
	totalDays := daysCount
	
	// 定期更新进度
	progressTicker := time.NewTicker(5 * time.Second)
	go func() {
		for range progressTicker.C {
			if completedDays >= totalDays {
				progressTicker.Stop()
				return
			}
			
			mu.Lock()
			progress := float64(completedDays) / float64(totalDays) * 100
			log.Printf("周结算任务进度: %.2f%% (%d/%d 天完成，已生成 %d 条数据)", 
				progress, completedDays, totalDays, processedCount)
			
			// 更新任务状态中的进度信息
			progressMsg := fmt.Sprintf("进度: %.2f%% (%d/%d 天)", progress, completedDays, totalDays)
			s.UpdateSettlementTaskStatus(taskID, "running", progressMsg)
			mu.Unlock()
		}
	}()
	
	// 并行计算每一天的结算数据
	for i := 0; i < daysCount; i++ {
		date := startDate.AddDate(0, 0, i)
		wg.Add(1)
		
		// 获取信号量，限制并发数
		semaphore <- struct{}{}
		
		// 使用匿名函数捕获当前日期变量
		go func(currentDate time.Time, dayIndex int) {
			defer wg.Done()
			defer func() { <-semaphore }() // 释放信号量
			
			log.Printf("开始计算 %s 的结算数据 (第 %d/%d 天)", 
				currentDate.Format("2006-01-02"), dayIndex+1, totalDays)
			
			// 计算当天所有学校的结算数据
			var daySettlements []model.SchoolSettlement
			dayCount := 0
			
			// 处理每个学校
			schoolCount := len(schools)
			for j, school := range schools {
				// 每处理完10个学校输出一次日志
				if j > 0 && j % 10 == 0 {
					log.Printf("处理 %s 的结算数据: 完成 %d/%d 个学校", 
						currentDate.Format("2006-01-02"), j, schoolCount)
				}
				
				// 计算指定学校和日期的结算数据
				settlementList, err := s.repo.CalculateDaily95WithRegionAndCPForAllRegionsAndCPs(currentDate, school.SchoolID)
				if err != nil {
					log.Printf("计算学校 %s 在 %s 的日95值失败: %v", 
						school.SchoolName, currentDate.Format("2006-01-02"), err)
					continue
				}
				
				// 添加到当日结算数据中
				daySettlements = append(daySettlements, settlementList...)
				dayCount += len(settlementList)
			}
			
			// 安全地更新共享数据
			mu.Lock()
			settlements = append(settlements, daySettlements...)
			processedCount += dayCount
			completedDays++ // 更新已完成的天数
			log.Printf("完成 %s 的结算任务，生成 %d 条数据 (进度: %d/%d 天)", 
				currentDate.Format("2006-01-02"), dayCount, completedDays, totalDays)
			mu.Unlock()
		}(date, i)
	}

	// 等待所有日期的结算任务完成
	log.Printf("等待所有日期的结算任务完成...")
	wg.Wait()

	// 等待所有工作协程完成
	log.Printf("等待所有工作协程完成...")
	wg.Wait()
	
	log.Printf("并发计算完成，共生成 %d 条结算数据", processedCount)

	// 批量保存结算数据
	log.Printf("开始保存结算数据，总数量: %d", len(settlements))
	if len(settlements) > 0 {
		// 打印前5条结算数据以便调试
		for i := 0; i < 5 && i < len(settlements); i++ {
			log.Printf("结算数据示例[%d]: 学校=%s, 区域=%s, CP=%s, 日期=%s, 值=%d", 
				i, settlements[i].SchoolName, settlements[i].Region, settlements[i].CP, 
				settlements[i].SettlementDate.Format("2006-01-02"), settlements[i].SettlementValue)
		}
		
		err = s.repo.BatchCreateSettlements(settlements)
		if err != nil {
			log.Printf("保存结算数据失败: %v", err)
			s.UpdateSettlementTaskStatus(taskID, "failed", fmt.Sprintf("保存结算数据失败: %v", err))
			return fmt.Errorf("保存结算数据失败: %v", err)
		}
		log.Printf("结算数据保存成功")
	} else {
		log.Printf("没有结算数据需要保存")
	}

	// 更新任务状态和处理记录数
	task, err := s.repo.GetSettlementTaskByID(taskID)
	if err != nil {
		return fmt.Errorf("获取任务信息失败: %v", err)
	}

	task.Status = "success"
	task.EndTime = time.Now()
	task.ProcessedCount = processedCount

	err = s.repo.UpdateSettlementTask(task)
	if err != nil {
		return fmt.Errorf("更新任务状态失败: %v", err)
	}

	return nil
}
